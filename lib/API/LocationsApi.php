<?php
/**
 * LocationsApi
 * PHP version 5
 *
 * @category Class
 * @package  GuestNetworks
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Guest Networks API
 *
 * This is the public API for the [Guest Networks platform](https://www.mywifinetworks.com).  All requests must include an App Secret Key for authentication. To get your App Secret Key: 1. Log in to your MyWiFi Control Panel 1. Navigate to Branding section 1. Note your API key, located in the App Secret Key field   <br/> # Available SDKs [PHP API Client](https://github.com/MyWiFiNetworks/PublicAPI-PHP)
 *
 * OpenAPI spec version: 1.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.19
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace GuestNetworks\API;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuestNetworks\ApiException;
use GuestNetworks\Configuration;
use GuestNetworks\HeaderSelector;
use GuestNetworks\ObjectSerializer;

/**
 * LocationsApi Class Doc Comment
 *
 * @category Class
 * @package  GuestNetworks
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LocationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation assignCampaign
     *
     * Assign Default Campaign to Location
     *
     * @param  int $location_id location_id (optional)
     * @param  int $campaign_id campaign_id (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function assignCampaign($location_id = null, $campaign_id = null)
    {
        $this->assignCampaignWithHttpInfo($location_id, $campaign_id);
    }

    /**
     * Operation assignCampaignWithHttpInfo
     *
     * Assign Default Campaign to Location
     *
     * @param  int $location_id (optional)
     * @param  int $campaign_id (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignCampaignWithHttpInfo($location_id = null, $campaign_id = null)
    {
        $returnType = '';
        $request = $this->assignCampaignRequest($location_id, $campaign_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation assignCampaignAsync
     *
     * Assign Default Campaign to Location
     *
     * @param  int $location_id (optional)
     * @param  int $campaign_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignCampaignAsync($location_id = null, $campaign_id = null)
    {
        return $this->assignCampaignAsyncWithHttpInfo($location_id, $campaign_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignCampaignAsyncWithHttpInfo
     *
     * Assign Default Campaign to Location
     *
     * @param  int $location_id (optional)
     * @param  int $campaign_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignCampaignAsyncWithHttpInfo($location_id = null, $campaign_id = null)
    {
        $returnType = '';
        $request = $this->assignCampaignRequest($location_id, $campaign_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignCampaign'
     *
     * @param  int $location_id (optional)
     * @param  int $campaign_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assignCampaignRequest($location_id = null, $campaign_id = null)
    {

        $resourcePath = '/location-assign-campaign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($campaign_id !== null) {
            $formParams['campaign_id'] = ObjectSerializer::toFormValue($campaign_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignCampaign
     *
     * Assign Default Campaign to Location
     *
     * @param  \GuestNetworks\Model\AssignCampaign $body body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function assignCampaign($body = null)
    {
        $this->assignCampaignWithHttpInfo($body);
    }

    /**
     * Operation assignCampaignWithHttpInfo
     *
     * Assign Default Campaign to Location
     *
     * @param  \GuestNetworks\Model\AssignCampaign $body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignCampaignWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->assignCampaignRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation assignCampaignAsync
     *
     * Assign Default Campaign to Location
     *
     * @param  \GuestNetworks\Model\AssignCampaign $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignCampaignAsync($body = null)
    {
        return $this->assignCampaignAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignCampaignAsyncWithHttpInfo
     *
     * Assign Default Campaign to Location
     *
     * @param  \GuestNetworks\Model\AssignCampaign $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignCampaignAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->assignCampaignRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignCampaign'
     *
     * @param  \GuestNetworks\Model\AssignCampaign $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assignCampaignRequest($body = null)
    {

        $resourcePath = '/location-assign-campaign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($campaign_id !== null) {
            $formParams['campaign_id'] = ObjectSerializer::toFormValue($campaign_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignDevice
     *
     * Assign Device to Location
     *
     * @param  int $location_id location_id (optional)
     * @param  int $device_id device_id (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function assignDevice($location_id = null, $device_id = null)
    {
        $this->assignDeviceWithHttpInfo($location_id, $device_id);
    }

    /**
     * Operation assignDeviceWithHttpInfo
     *
     * Assign Device to Location
     *
     * @param  int $location_id (optional)
     * @param  int $device_id (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignDeviceWithHttpInfo($location_id = null, $device_id = null)
    {
        $returnType = '';
        $request = $this->assignDeviceRequest($location_id, $device_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation assignDeviceAsync
     *
     * Assign Device to Location
     *
     * @param  int $location_id (optional)
     * @param  int $device_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignDeviceAsync($location_id = null, $device_id = null)
    {
        return $this->assignDeviceAsyncWithHttpInfo($location_id, $device_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignDeviceAsyncWithHttpInfo
     *
     * Assign Device to Location
     *
     * @param  int $location_id (optional)
     * @param  int $device_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignDeviceAsyncWithHttpInfo($location_id = null, $device_id = null)
    {
        $returnType = '';
        $request = $this->assignDeviceRequest($location_id, $device_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignDevice'
     *
     * @param  int $location_id (optional)
     * @param  int $device_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assignDeviceRequest($location_id = null, $device_id = null)
    {

        $resourcePath = '/device-assign-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($device_id !== null) {
            $formParams['device_id'] = ObjectSerializer::toFormValue($device_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignDevice
     *
     * Assign Device to Location
     *
     * @param  \GuestNetworks\Model\AssignDevice $body body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function assignDevice($body = null)
    {
        $this->assignDeviceWithHttpInfo($body);
    }

    /**
     * Operation assignDeviceWithHttpInfo
     *
     * Assign Device to Location
     *
     * @param  \GuestNetworks\Model\AssignDevice $body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignDeviceWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->assignDeviceRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation assignDeviceAsync
     *
     * Assign Device to Location
     *
     * @param  \GuestNetworks\Model\AssignDevice $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignDeviceAsync($body = null)
    {
        return $this->assignDeviceAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignDeviceAsyncWithHttpInfo
     *
     * Assign Device to Location
     *
     * @param  \GuestNetworks\Model\AssignDevice $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignDeviceAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->assignDeviceRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignDevice'
     *
     * @param  \GuestNetworks\Model\AssignDevice $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assignDeviceRequest($body = null)
    {

        $resourcePath = '/device-assign-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($device_id !== null) {
            $formParams['device_id'] = ObjectSerializer::toFormValue($device_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrUpdateLocation
     *
     * Create or Update a Location
     *
     * @param  int $location_id location_id (optional)
     * @param  string $location_name location_name (optional)
     * @param  string $address1 address1 (optional)
     * @param  string $town town (optional)
     * @param  string $state state (optional)
     * @param  string $zipcode zipcode (optional)
     * @param  string $country country (optional)
     * @param  string $phone_number phone_number (optional)
     * @param  string $timezone timezone (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createOrUpdateLocation($location_id = null, $location_name = null, $address1 = null, $town = null, $state = null, $zipcode = null, $country = null, $phone_number = null, $timezone = null)
    {
        $this->createOrUpdateLocationWithHttpInfo($location_id, $location_name, $address1, $town, $state, $zipcode, $country, $phone_number, $timezone);
    }

    /**
     * Operation createOrUpdateLocationWithHttpInfo
     *
     * Create or Update a Location
     *
     * @param  int $location_id (optional)
     * @param  string $location_name (optional)
     * @param  string $address1 (optional)
     * @param  string $town (optional)
     * @param  string $state (optional)
     * @param  string $zipcode (optional)
     * @param  string $country (optional)
     * @param  string $phone_number (optional)
     * @param  string $timezone (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrUpdateLocationWithHttpInfo($location_id = null, $location_name = null, $address1 = null, $town = null, $state = null, $zipcode = null, $country = null, $phone_number = null, $timezone = null)
    {
        $returnType = '';
        $request = $this->createOrUpdateLocationRequest($location_id, $location_name, $address1, $town, $state, $zipcode, $country, $phone_number, $timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createOrUpdateLocationAsync
     *
     * Create or Update a Location
     *
     * @param  int $location_id (optional)
     * @param  string $location_name (optional)
     * @param  string $address1 (optional)
     * @param  string $town (optional)
     * @param  string $state (optional)
     * @param  string $zipcode (optional)
     * @param  string $country (optional)
     * @param  string $phone_number (optional)
     * @param  string $timezone (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateLocationAsync($location_id = null, $location_name = null, $address1 = null, $town = null, $state = null, $zipcode = null, $country = null, $phone_number = null, $timezone = null)
    {
        return $this->createOrUpdateLocationAsyncWithHttpInfo($location_id, $location_name, $address1, $town, $state, $zipcode, $country, $phone_number, $timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrUpdateLocationAsyncWithHttpInfo
     *
     * Create or Update a Location
     *
     * @param  int $location_id (optional)
     * @param  string $location_name (optional)
     * @param  string $address1 (optional)
     * @param  string $town (optional)
     * @param  string $state (optional)
     * @param  string $zipcode (optional)
     * @param  string $country (optional)
     * @param  string $phone_number (optional)
     * @param  string $timezone (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateLocationAsyncWithHttpInfo($location_id = null, $location_name = null, $address1 = null, $town = null, $state = null, $zipcode = null, $country = null, $phone_number = null, $timezone = null)
    {
        $returnType = '';
        $request = $this->createOrUpdateLocationRequest($location_id, $location_name, $address1, $town, $state, $zipcode, $country, $phone_number, $timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrUpdateLocation'
     *
     * @param  int $location_id (optional)
     * @param  string $location_name (optional)
     * @param  string $address1 (optional)
     * @param  string $town (optional)
     * @param  string $state (optional)
     * @param  string $zipcode (optional)
     * @param  string $country (optional)
     * @param  string $phone_number (optional)
     * @param  string $timezone (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOrUpdateLocationRequest($location_id = null, $location_name = null, $address1 = null, $town = null, $state = null, $zipcode = null, $country = null, $phone_number = null, $timezone = null)
    {

        $resourcePath = '/create-or-update-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($location_name !== null) {
            $formParams['location_name'] = ObjectSerializer::toFormValue($location_name);
        }
        // form params
        if ($address1 !== null) {
            $formParams['address1'] = ObjectSerializer::toFormValue($address1);
        }
        // form params
        if ($town !== null) {
            $formParams['town'] = ObjectSerializer::toFormValue($town);
        }
        // form params
        if ($state !== null) {
            $formParams['state'] = ObjectSerializer::toFormValue($state);
        }
        // form params
        if ($zipcode !== null) {
            $formParams['zipcode'] = ObjectSerializer::toFormValue($zipcode);
        }
        // form params
        if ($country !== null) {
            $formParams['country'] = ObjectSerializer::toFormValue($country);
        }
        // form params
        if ($phone_number !== null) {
            $formParams['phone_number'] = ObjectSerializer::toFormValue($phone_number);
        }
        // form params
        if ($timezone !== null) {
            $formParams['timezone'] = ObjectSerializer::toFormValue($timezone);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrUpdateLocation
     *
     * Create or Update a Location
     *
     * @param  \GuestNetworks\Model\Location $body body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createOrUpdateLocation($body = null)
    {
        $this->createOrUpdateLocationWithHttpInfo($body);
    }

    /**
     * Operation createOrUpdateLocationWithHttpInfo
     *
     * Create or Update a Location
     *
     * @param  \GuestNetworks\Model\Location $body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrUpdateLocationWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->createOrUpdateLocationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createOrUpdateLocationAsync
     *
     * Create or Update a Location
     *
     * @param  \GuestNetworks\Model\Location $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateLocationAsync($body = null)
    {
        return $this->createOrUpdateLocationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrUpdateLocationAsyncWithHttpInfo
     *
     * Create or Update a Location
     *
     * @param  \GuestNetworks\Model\Location $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateLocationAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->createOrUpdateLocationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrUpdateLocation'
     *
     * @param  \GuestNetworks\Model\Location $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOrUpdateLocationRequest($body = null)
    {

        $resourcePath = '/create-or-update-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($location_name !== null) {
            $formParams['location_name'] = ObjectSerializer::toFormValue($location_name);
        }
        // form params
        if ($address1 !== null) {
            $formParams['address1'] = ObjectSerializer::toFormValue($address1);
        }
        // form params
        if ($town !== null) {
            $formParams['town'] = ObjectSerializer::toFormValue($town);
        }
        // form params
        if ($state !== null) {
            $formParams['state'] = ObjectSerializer::toFormValue($state);
        }
        // form params
        if ($zipcode !== null) {
            $formParams['zipcode'] = ObjectSerializer::toFormValue($zipcode);
        }
        // form params
        if ($country !== null) {
            $formParams['country'] = ObjectSerializer::toFormValue($country);
        }
        // form params
        if ($phone_number !== null) {
            $formParams['phone_number'] = ObjectSerializer::toFormValue($phone_number);
        }
        // form params
        if ($timezone !== null) {
            $formParams['timezone'] = ObjectSerializer::toFormValue($timezone);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLocation
     *
     * Delete a Location
     *
     * @param  int $location_id location_id (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteLocation($location_id = null)
    {
        $this->deleteLocationWithHttpInfo($location_id);
    }

    /**
     * Operation deleteLocationWithHttpInfo
     *
     * Delete a Location
     *
     * @param  int $location_id (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLocationWithHttpInfo($location_id = null)
    {
        $returnType = '';
        $request = $this->deleteLocationRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLocationAsync
     *
     * Delete a Location
     *
     * @param  int $location_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLocationAsync($location_id = null)
    {
        return $this->deleteLocationAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLocationAsyncWithHttpInfo
     *
     * Delete a Location
     *
     * @param  int $location_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLocationAsyncWithHttpInfo($location_id = null)
    {
        $returnType = '';
        $request = $this->deleteLocationRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLocation'
     *
     * @param  int $location_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteLocationRequest($location_id = null)
    {

        $resourcePath = '/delete-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLocation
     *
     * Delete a Location
     *
     * @param  \GuestNetworks\Model\DeleteLocation $body body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteLocation($body = null)
    {
        $this->deleteLocationWithHttpInfo($body);
    }

    /**
     * Operation deleteLocationWithHttpInfo
     *
     * Delete a Location
     *
     * @param  \GuestNetworks\Model\DeleteLocation $body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLocationWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->deleteLocationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLocationAsync
     *
     * Delete a Location
     *
     * @param  \GuestNetworks\Model\DeleteLocation $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLocationAsync($body = null)
    {
        return $this->deleteLocationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLocationAsyncWithHttpInfo
     *
     * Delete a Location
     *
     * @param  \GuestNetworks\Model\DeleteLocation $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLocationAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->deleteLocationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLocation'
     *
     * @param  \GuestNetworks\Model\DeleteLocation $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteLocationRequest($body = null)
    {

        $resourcePath = '/delete-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocation
     *
     * Retrieve data for multiple or single Location(s)
     *
     * @param  int[] $location_ids A comma-separated list of location IDs. (required)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getLocation($location_ids)
    {
        $this->getLocationWithHttpInfo($location_ids);
    }

    /**
     * Operation getLocationWithHttpInfo
     *
     * Retrieve data for multiple or single Location(s)
     *
     * @param  int[] $location_ids A comma-separated list of location IDs. (required)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocationWithHttpInfo($location_ids)
    {
        $returnType = '';
        $request = $this->getLocationRequest($location_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getLocationAsync
     *
     * Retrieve data for multiple or single Location(s)
     *
     * @param  int[] $location_ids A comma-separated list of location IDs. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationAsync($location_ids)
    {
        return $this->getLocationAsyncWithHttpInfo($location_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocationAsyncWithHttpInfo
     *
     * Retrieve data for multiple or single Location(s)
     *
     * @param  int[] $location_ids A comma-separated list of location IDs. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationAsyncWithHttpInfo($location_ids)
    {
        $returnType = '';
        $request = $this->getLocationRequest($location_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocation'
     *
     * @param  int[] $location_ids A comma-separated list of location IDs. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLocationRequest($location_ids)
    {
        // verify the required parameter 'location_ids' is set
        if ($location_ids === null || (is_array($location_ids) && count($location_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_ids when calling getLocation'
            );
        }

        $resourcePath = '/get-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($location_ids)) {
            $location_ids = ObjectSerializer::serializeCollection($location_ids, 'multi', true);
        }
        if ($location_ids !== null) {
            $queryParams['location_ids'] = ObjectSerializer::toQueryValue($location_ids);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocationDevices
     *
     * List all Devices assigned to Location
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getLocationDevices($location_id)
    {
        $this->getLocationDevicesWithHttpInfo($location_id);
    }

    /**
     * Operation getLocationDevicesWithHttpInfo
     *
     * List all Devices assigned to Location
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocationDevicesWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->getLocationDevicesRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getLocationDevicesAsync
     *
     * List all Devices assigned to Location
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationDevicesAsync($location_id)
    {
        return $this->getLocationDevicesAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocationDevicesAsyncWithHttpInfo
     *
     * List all Devices assigned to Location
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationDevicesAsyncWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->getLocationDevicesRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocationDevices'
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLocationDevicesRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling getLocationDevices'
            );
        }

        $resourcePath = '/get-location-devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($location_id !== null) {
            $queryParams['location_id'] = ObjectSerializer::toQueryValue($location_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocationOptions
     *
     * Retrieve Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getLocationOptions($location_id)
    {
        $this->getLocationOptionsWithHttpInfo($location_id);
    }

    /**
     * Operation getLocationOptionsWithHttpInfo
     *
     * Retrieve Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocationOptionsWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->getLocationOptionsRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getLocationOptionsAsync
     *
     * Retrieve Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationOptionsAsync($location_id)
    {
        return $this->getLocationOptionsAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocationOptionsAsyncWithHttpInfo
     *
     * Retrieve Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationOptionsAsyncWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->getLocationOptionsRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocationOptions'
     *
     * @param  int $location_id The Location ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLocationOptionsRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling getLocationOptions'
            );
        }

        $resourcePath = '/get-location-options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($location_id !== null) {
            $queryParams['location_id'] = ObjectSerializer::toQueryValue($location_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation locationList
     *
     * Retrieve list of all Locations
     *
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function locationList()
    {
        $this->locationListWithHttpInfo();
    }

    /**
     * Operation locationListWithHttpInfo
     *
     * Retrieve list of all Locations
     *
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function locationListWithHttpInfo()
    {
        $returnType = '';
        $request = $this->locationListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation locationListAsync
     *
     * Retrieve list of all Locations
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationListAsync()
    {
        return $this->locationListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation locationListAsyncWithHttpInfo
     *
     * Retrieve list of all Locations
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationListAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->locationListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'locationList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function locationListRequest()
    {

        $resourcePath = '/location-list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLocationOptions
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id location_id (optional)
     * @param  int $session_time_limit session_time_limit (optional)
     * @param  int $max_bandwidth max_bandwidth (optional)
     * @param  int $max_bandwidth_up max_bandwidth_up (optional)
     * @param  int $daily_bandwidth_cap daily_bandwidth_cap (optional)
     * @param  int $content_filter content_filter (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateLocationOptions($location_id = null, $session_time_limit = null, $max_bandwidth = null, $max_bandwidth_up = null, $daily_bandwidth_cap = null, $content_filter = null)
    {
        $this->updateLocationOptionsWithHttpInfo($location_id, $session_time_limit, $max_bandwidth, $max_bandwidth_up, $daily_bandwidth_cap, $content_filter);
    }

    /**
     * Operation updateLocationOptionsWithHttpInfo
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id (optional)
     * @param  int $session_time_limit (optional)
     * @param  int $max_bandwidth (optional)
     * @param  int $max_bandwidth_up (optional)
     * @param  int $daily_bandwidth_cap (optional)
     * @param  int $content_filter (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLocationOptionsWithHttpInfo($location_id = null, $session_time_limit = null, $max_bandwidth = null, $max_bandwidth_up = null, $daily_bandwidth_cap = null, $content_filter = null)
    {
        $returnType = '';
        $request = $this->updateLocationOptionsRequest($location_id, $session_time_limit, $max_bandwidth, $max_bandwidth_up, $daily_bandwidth_cap, $content_filter);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateLocationOptionsAsync
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id (optional)
     * @param  int $session_time_limit (optional)
     * @param  int $max_bandwidth (optional)
     * @param  int $max_bandwidth_up (optional)
     * @param  int $daily_bandwidth_cap (optional)
     * @param  int $content_filter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLocationOptionsAsync($location_id = null, $session_time_limit = null, $max_bandwidth = null, $max_bandwidth_up = null, $daily_bandwidth_cap = null, $content_filter = null)
    {
        return $this->updateLocationOptionsAsyncWithHttpInfo($location_id, $session_time_limit, $max_bandwidth, $max_bandwidth_up, $daily_bandwidth_cap, $content_filter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLocationOptionsAsyncWithHttpInfo
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  int $location_id (optional)
     * @param  int $session_time_limit (optional)
     * @param  int $max_bandwidth (optional)
     * @param  int $max_bandwidth_up (optional)
     * @param  int $daily_bandwidth_cap (optional)
     * @param  int $content_filter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLocationOptionsAsyncWithHttpInfo($location_id = null, $session_time_limit = null, $max_bandwidth = null, $max_bandwidth_up = null, $daily_bandwidth_cap = null, $content_filter = null)
    {
        $returnType = '';
        $request = $this->updateLocationOptionsRequest($location_id, $session_time_limit, $max_bandwidth, $max_bandwidth_up, $daily_bandwidth_cap, $content_filter);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateLocationOptions'
     *
     * @param  int $location_id (optional)
     * @param  int $session_time_limit (optional)
     * @param  int $max_bandwidth (optional)
     * @param  int $max_bandwidth_up (optional)
     * @param  int $daily_bandwidth_cap (optional)
     * @param  int $content_filter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateLocationOptionsRequest($location_id = null, $session_time_limit = null, $max_bandwidth = null, $max_bandwidth_up = null, $daily_bandwidth_cap = null, $content_filter = null)
    {

        $resourcePath = '/set-session-and-bandwidth-info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($session_time_limit !== null) {
            $formParams['session_time_limit'] = ObjectSerializer::toFormValue($session_time_limit);
        }
        // form params
        if ($max_bandwidth !== null) {
            $formParams['max_bandwidth'] = ObjectSerializer::toFormValue($max_bandwidth);
        }
        // form params
        if ($max_bandwidth_up !== null) {
            $formParams['max_bandwidth_up'] = ObjectSerializer::toFormValue($max_bandwidth_up);
        }
        // form params
        if ($daily_bandwidth_cap !== null) {
            $formParams['daily_bandwidth_cap'] = ObjectSerializer::toFormValue($daily_bandwidth_cap);
        }
        // form params
        if ($content_filter !== null) {
            $formParams['content_filter'] = ObjectSerializer::toFormValue($content_filter);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLocationOptions
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  \GuestNetworks\Model\LocationOption $body body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateLocationOptions($body = null)
    {
        $this->updateLocationOptionsWithHttpInfo($body);
    }

    /**
     * Operation updateLocationOptionsWithHttpInfo
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  \GuestNetworks\Model\LocationOption $body (optional)
     *
     * @throws \GuestNetworks\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLocationOptionsWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->updateLocationOptionsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateLocationOptionsAsync
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  \GuestNetworks\Model\LocationOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLocationOptionsAsync($body = null)
    {
        return $this->updateLocationOptionsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLocationOptionsAsyncWithHttpInfo
     *
     * Update Location Options / Settings [RADIUS Attributes]
     *
     * @param  \GuestNetworks\Model\LocationOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLocationOptionsAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->updateLocationOptionsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateLocationOptions'
     *
     * @param  \GuestNetworks\Model\LocationOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateLocationOptionsRequest($body = null)
    {

        $resourcePath = '/set-session-and-bandwidth-info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($location_id !== null) {
            $formParams['location_id'] = ObjectSerializer::toFormValue($location_id);
        }
        // form params
        if ($session_time_limit !== null) {
            $formParams['session_time_limit'] = ObjectSerializer::toFormValue($session_time_limit);
        }
        // form params
        if ($max_bandwidth !== null) {
            $formParams['max_bandwidth'] = ObjectSerializer::toFormValue($max_bandwidth);
        }
        // form params
        if ($max_bandwidth_up !== null) {
            $formParams['max_bandwidth_up'] = ObjectSerializer::toFormValue($max_bandwidth_up);
        }
        // form params
        if ($daily_bandwidth_cap !== null) {
            $formParams['daily_bandwidth_cap'] = ObjectSerializer::toFormValue($daily_bandwidth_cap);
        }
        // form params
        if ($content_filter !== null) {
            $formParams['content_filter'] = ObjectSerializer::toFormValue($content_filter);
        }
        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('identifier');
        if ($apiKey !== null) {
            $headers['identifier'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
